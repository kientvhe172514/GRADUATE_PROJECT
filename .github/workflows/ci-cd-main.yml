name: ðŸš€ Smart CI/CD Pipeline - AWS EC2

permissions:
  contents: read
  packages: write

on:
  push:
    branches: [main, develop, KiÃªn]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      service:
        description: 'Force deploy specific service'
        required: false
        type: choice
        options:
          - all
          - auth
          - face-recognition
          - attendance
          - employee
          - leave
          - notification
          - reporting

env:
  AWS_REGION: ap-southeast-1
  REGISTRY: docker.io
  REGISTRY_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}

jobs:
  # ==========================================
  # JOB 1: DETECT CHANGES
  # ==========================================
  detect-changes:
    name: ðŸ” Detect Changed Services
    runs-on: ubuntu-latest
    outputs:
      auth: ${{ steps.filter.outputs.auth }}
      face-recognition: ${{ steps.filter.outputs.face-recognition }}
      attendance: ${{ steps.filter.outputs.attendance }}
      employee: ${{ steps.filter.outputs.employee }}
      leave: ${{ steps.filter.outputs.leave }}
      notification: ${{ steps.filter.outputs.notification }}
      reporting: ${{ steps.filter.outputs.reporting }}
      infra: ${{ steps.filter.outputs.infra }}
      shared: ${{ steps.filter.outputs.shared }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check changed files
        uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            auth:
              - 'services/auth/**'
              - 'infra/k8s/services/auth/**'
            face-recognition:
              - 'services/face-recognition/**'
              - 'infra/k8s/services/face-recognition/**'
            attendance:
              - 'services/attendance/**'
              - 'infra/k8s/services/attendance/**'
            employee:
              - 'services/employee/**'
              - 'infra/k8s/services/employee/**'
            leave:
              - 'services/leave/**'
              - 'infra/k8s/services/leave/**'
            notification:
              - 'services/notification/**'
              - 'infra/k8s/services/notification/**'
            reporting:
              - 'services/reporting/**'
              - 'infra/k8s/services/reporting/**'
            infra:
              - 'infra/k8s/platform/**'
              - 'infra/k8s/shared/**'
            shared:
              - 'services/shared-common/**'
              - 'pnpm-lock.yaml'
              - 'package.json'

      - name: Print detected changes
        run: |
          echo "ðŸ” Changed Services:"
          echo "Auth: ${{ steps.filter.outputs.auth }}"
          echo "Face Recognition: ${{ steps.filter.outputs.face-recognition }}"
          echo "Attendance: ${{ steps.filter.outputs.attendance }}"
          echo "Employee: ${{ steps.filter.outputs.employee }}"
          echo "Leave: ${{ steps.filter.outputs.leave }}"
          echo "Notification: ${{ steps.filter.outputs.notification }}"
          echo "Reporting: ${{ steps.filter.outputs.reporting }}"
          echo "Infrastructure: ${{ steps.filter.outputs.infra }}"
          echo "Shared: ${{ steps.filter.outputs.shared }}"

  # ==========================================
  # JOB 2: BUILD SHARED COMMON (IF CHANGED)
  # ==========================================
  build-shared:
    name: ðŸ“¦ Build Shared Common
    needs: detect-changes
    if: |
      needs.detect-changes.outputs.shared == 'true' ||
      needs.detect-changes.outputs.auth == 'true' ||
      needs.detect-changes.outputs.attendance == 'true' ||
      needs.detect-changes.outputs.employee == 'true' ||
      needs.detect-changes.outputs.leave == 'true' ||
      needs.detect-changes.outputs.notification == 'true' ||
      needs.detect-changes.outputs.reporting == 'true' ||
      github.event.inputs.service != ''
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build shared-common
        run: pnpm --filter @graduate-project/shared-common build

      - name: Cache shared build
        uses: actions/cache@v4
        with:
          path: services/shared-common/dist
          key: shared-build-${{ github.sha }}

  # ==========================================
  # JOB 3: BUILD & PUSH AUTH SERVICE
  # ==========================================
  build-auth:
    name: ðŸ” Build Auth Service
    needs: [detect-changes, build-shared]
    if: |
      always() &&
      (needs.detect-changes.outputs.auth == 'true' || 
       needs.detect-changes.outputs.shared == 'true' ||
       github.event.inputs.service == 'all' ||
       github.event.inputs.service == 'auth')
    uses: ./.github/workflows/build-service.yml
    with:
      service-name: auth
      service-path: services/auth
      dockerfile: Dockerfile
      build-args: |
        NODE_ENV=production
    secrets: inherit

  # ==========================================
  # JOB 4: BUILD & PUSH FACE RECOGNITION
  # ==========================================
  build-face-recognition:
    name: ðŸ‘¤ Build Face Recognition Service
    needs: [detect-changes]
    if: |
      always() &&
      (needs.detect-changes.outputs.face-recognition == 'true' ||
       github.event.inputs.service == 'all' ||
       github.event.inputs.service == 'face-recognition')
    uses: ./.github/workflows/build-dotnet-service.yml
    with:
      service-name: face-recognition
      service-path: services/face-recognition
      dockerfile: src/Zentry.API/Dockerfile
      build-args: |
        ASPNETCORE_ENVIRONMENT=Production
    secrets: inherit

  # ==========================================
  # JOB 5: BUILD & PUSH ATTENDANCE SERVICE
  # ==========================================
  build-attendance:
    name: â° Build Attendance Service
    needs: [detect-changes, build-shared]
    if: |
      always() &&
      (needs.detect-changes.outputs.attendance == 'true' ||
       needs.detect-changes.outputs.shared == 'true' ||
       github.event.inputs.service == 'all' ||
       github.event.inputs.service == 'attendance')
    uses: ./.github/workflows/build-service.yml
    with:
      service-name: attendance
      service-path: services/attendance
      dockerfile: Dockerfile
      build-args: |
        NODE_ENV=production
    secrets: inherit

  # ==========================================
  # JOB 6: BUILD & PUSH EMPLOYEE SERVICE
  # ==========================================
  build-employee:
    name: ðŸ‘¥ Build Employee Service
    needs: [detect-changes, build-shared]
    if: |
      always() &&
      (needs.detect-changes.outputs.employee == 'true' ||
       needs.detect-changes.outputs.shared == 'true' ||
       github.event.inputs.service == 'all' ||
       github.event.inputs.service == 'employee')
    uses: ./.github/workflows/build-service.yml
    with:
      service-name: employee
      service-path: services/employee
      dockerfile: Dockerfile
      build-args: |
        NODE_ENV=production
    secrets: inherit

  # ==========================================
  # JOB 7: BUILD & PUSH LEAVE SERVICE
  # ==========================================
  build-leave:
    name: ðŸ–ï¸ Build Leave Service
    needs: [detect-changes, build-shared]
    if: |
      always() &&
      (needs.detect-changes.outputs.leave == 'true' ||
       needs.detect-changes.outputs.shared == 'true' ||
       github.event.inputs.service == 'all' ||
       github.event.inputs.service == 'leave')
    uses: ./.github/workflows/build-service.yml
    with:
      service-name: leave
      service-path: services/leave
      dockerfile: Dockerfile
      build-args: |
        NODE_ENV=production
    secrets: inherit

  # ==========================================
  # JOB 8: BUILD & PUSH NOTIFICATION SERVICE
  # ==========================================
  build-notification:
    name: ðŸ”” Build Notification Service
    needs: [detect-changes, build-shared]
    if: |
      always() &&
      (needs.detect-changes.outputs.notification == 'true' ||
       needs.detect-changes.outputs.shared == 'true' ||
       github.event.inputs.service == 'all' ||
       github.event.inputs.service == 'notification')
    uses: ./.github/workflows/build-service.yml
    with:
      service-name: notification
      service-path: services/notification
      dockerfile: Dockerfile
      build-args: |
        NODE_ENV=production
    secrets: inherit

  # ==========================================
  # JOB 9: BUILD & PUSH REPORTING SERVICE
  # ==========================================
  build-reporting:
    name: ðŸ“Š Build Reporting Service
    needs: [detect-changes, build-shared]
    if: |
      always() &&
      (needs.detect-changes.outputs.reporting == 'true' ||
       needs.detect-changes.outputs.shared == 'true' ||
       github.event.inputs.service == 'all' ||
       github.event.inputs.service == 'reporting')
    uses: ./.github/workflows/build-service.yml
    with:
      service-name: reporting
      service-path: services/reporting
      dockerfile: Dockerfile
      build-args: |
        NODE_ENV=production
    secrets: inherit

  # ==========================================
  # JOB 10: DEPLOY INFRASTRUCTURE TO AWS EC2
  # ==========================================
  deploy-infrastructure:
    name: ðŸ—ï¸ Deploy Infrastructure to EC2
    needs: detect-changes
    # âœ… CHá»ˆ CHáº Y KHI CÃ“ THAY Äá»”I INFRASTRUCTURE HOáº¶C MANUAL TRIGGER
    if: |
      needs.detect-changes.outputs.infra == 'true' ||
      github.event.inputs.service == 'all'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts

      - name: Setup git credentials on EC2
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            # Configure git to use token for private repo
            git config --global credential.helper store
            echo "https://${{ secrets.GH_TOKEN }}:x-oauth-basic@github.com" > ~/.git-credentials
          EOF

      - name: Setup infrastructure secrets and deploy
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            set -e
            cd ~/GRADUATE_PROJECT
            git pull origin main
            
            # ============================================
            # CREATE INFRASTRUCTURE SECRETS (An toÃ n)
            # ============================================
            
            # XÃ“A Táº¤T Cáº¢ SECRETS CÅ¨ TRÆ¯á»šC (Ä‘á»ƒ trÃ¡nh merge keys cÅ©)
            echo "ðŸ—‘ï¸  Deleting old secrets..."
            kubectl delete secret postgres-secret -n infrastructure --ignore-not-found=true
            kubectl delete secret mongodb-secret -n infrastructure --ignore-not-found=true
            kubectl delete secret rabbitmq-secret -n infrastructure --ignore-not-found=true
            kubectl delete secret redis-secret -n infrastructure --ignore-not-found=true
            
            # Postgres Secret - FIX: ThÃªm Ä‘áº§y Ä‘á»§ database names + replicator password
            kubectl create secret generic postgres-secret \
              --from-literal=POSTGRES_HOST='${{ secrets.POSTGRES_HOST }}' \
              --from-literal=POSTGRES_PORT='${{ secrets.POSTGRES_PORT }}' \
              --from-literal=POSTGRES_USER='${{ secrets.POSTGRES_USER }}' \
              --from-literal=POSTGRES_PASSWORD='${{ secrets.POSTGRES_PASSWORD }}' \
              --from-literal=replicator-password='${{ secrets.POSTGRES_PASSWORD }}' \
              --from-literal=POSTGRES_DB='postgres' \
              --from-literal=POSTGRES_DB_IAM='${{ secrets.POSTGRES_DB_IAM }}' \
              --from-literal=POSTGRES_DB_ATTENDANCE='${{ secrets.POSTGRES_DB_ATTENDANCE }}' \
              --from-literal=POSTGRES_DB_EMPLOYEE='${{ secrets.POSTGRES_DB_EMPLOYEE }}' \
              --from-literal=POSTGRES_DB_LEAVE='${{ secrets.POSTGRES_DB_LEAVE }}' \
              --from-literal=POSTGRES_DB_NOTIFICATION='${{ secrets.POSTGRES_DB_NOTIFICATION }}' \
              --from-literal=POSTGRES_DB_REPORTING='${{ secrets.POSTGRES_DB_REPORTING }}' \
              --from-literal=POSTGRES_DB_ZENTRY='${{ secrets.POSTGRES_DB_ZENTRY }}' \
              -n infrastructure
            
            # MongoDB Secret - FIX: DÃ¹ng keys chuáº©n cá»§a MongoDB image
            kubectl create secret generic mongodb-secret \
              --from-literal=MONGO_INITDB_ROOT_USERNAME='${{ secrets.MONGODB_USERNAME }}' \
              --from-literal=MONGO_INITDB_ROOT_PASSWORD='${{ secrets.MONGODB_PASSWORD }}' \
              --from-literal=MONGO_INITDB_DATABASE='${{ secrets.MONGODB_DATABASE }}' \
              --from-literal=MONGODB_HOST='${{ secrets.MONGODB_HOST }}' \
              --from-literal=MONGODB_PORT='${{ secrets.MONGODB_PORT }}' \
              -n infrastructure
            
            # RabbitMQ Secret - FIX: Add both key formats (uppercase and lowercase)
            kubectl create secret generic rabbitmq-secret \
              --from-literal=RABBITMQ_DEFAULT_USER='${{ secrets.RABBITMQ_USERNAME }}' \
              --from-literal=RABBITMQ_DEFAULT_PASS='${{ secrets.RABBITMQ_PASSWORD }}' \
              --from-literal=username='${{ secrets.RABBITMQ_USERNAME }}' \
              --from-literal=password='${{ secrets.RABBITMQ_PASSWORD }}' \
              --from-literal=erlang-cookie='$(openssl rand -base64 32)' \
              --from-literal=RABBITMQ_HOST='${{ secrets.RABBITMQ_HOST }}' \
              --from-literal=RABBITMQ_PORT='${{ secrets.RABBITMQ_PORT }}' \
              --from-literal=RABBITMQ_MANAGEMENT_PORT='${{ secrets.RABBITMQ_MANAGEMENT_PORT }}' \
              -n infrastructure
            
            # Redis Secret - FIX: ThÃªm cáº£ 2 keys (in hoa vÃ  in thÆ°á»ng) Ä‘á»ƒ tÆ°Æ¡ng thÃ­ch
            kubectl create secret generic redis-secret \
              --from-literal=REDIS_PASSWORD='${{ secrets.REDIS_PASSWORD }}' \
              --from-literal=redis-password='${{ secrets.REDIS_PASSWORD }}' \
              --from-literal=REDIS_HOST='${{ secrets.REDIS_HOST }}' \
              --from-literal=REDIS_PORT='${{ secrets.REDIS_PORT }}' \
              -n infrastructure
            
            # ============================================
            # APPLY INFRASTRUCTURE CHANGES (KHÃ”NG XÃ“A - CHá»ˆ Cáº¬P NHáº¬T)
            # ============================================
            echo "ï¿½ Applying infrastructure changes (rolling update)..."
            # Deploy platform resources
            kubectl apply -f infra/k8s/platform/
            
            # Deploy Postgres (HA StatefulSet contains everything)
            kubectl apply -f infra/k8s/shared/databases/postgres/postgres-ha-statefulset.yaml
            kubectl apply -f infra/k8s/shared/databases/postgres/postgres-ha-config.yaml
            
            # Deploy MongoDB
            kubectl apply -f infra/k8s/shared/databases/mongodb/mongodb-deployment.yaml
            kubectl apply -f infra/k8s/shared/databases/mongodb/mongodb-service.yaml
            kubectl apply -f infra/k8s/shared/databases/mongodb/mongodb-pvc.yaml
            
            # Deploy RabbitMQ
            kubectl apply -f infra/k8s/shared/messaging/rabbitmq/rabbitmq-statefulset.yaml
            kubectl apply -f infra/k8s/shared/messaging/rabbitmq/rabbitmq-config.yaml
            
            # Deploy Redis (Sentinel mode with Master/Replica)
            kubectl apply -f infra/k8s/shared/messaging/redis/redis-config.yaml
            kubectl apply -f infra/k8s/shared/messaging/redis/redis-sentinel-config.yaml
            kubectl apply -f infra/k8s/shared/messaging/redis/redis-sentinel-statefulset.yaml
            
            # Deploy Monitoring Stack (Prometheus, Grafana, Alertmanager, Fluentd)
            echo "ðŸ“Š Deploying Monitoring Stack..."
            
            # âš ï¸ KHÃ”NG XÃ“A PVC - Giá»¯ láº¡i data cá»§a Prometheus vÃ  Grafana
            # kubectl delete pvc prometheus-storage grafana-storage -n monitoring --ignore-not-found=true
            
            # Apply monitoring stack (PVCs sáº½ giá»¯ nguyÃªn náº¿u Ä‘Ã£ tá»“n táº¡i)
            kubectl apply -f infra/k8s/shared/monitoring/ --recursive
            
            # XÃ³a pods Completed/Failed (khÃ´ng tá»± terminate)
            echo "ðŸ§¹ Cleaning up completed/failed pods..."
            kubectl delete pods -n monitoring --field-selector=status.phase=Completed --ignore-not-found=true || true
            kubectl delete pods -n monitoring --field-selector=status.phase=Failed --ignore-not-found=true || true
            
            # Rollout restart sáº½ Tá»° Äá»˜NG terminate pods cÅ© vÃ  táº¡o pods má»›i
            echo "ðŸ”„ Rolling restart monitoring (auto-terminate old pods)..."
            kubectl rollout restart deployment/prometheus-depl -n monitoring || echo "âš ï¸ Prometheus deployment not found"
            kubectl rollout restart deployment/grafana-depl -n monitoring || echo "âš ï¸ Grafana deployment not found"
            kubectl rollout restart deployment/alertmanager-depl -n monitoring || echo "âš ï¸ Alertmanager deployment not found"
            kubectl rollout restart statefulset/elasticsearch -n monitoring || echo "âš ï¸ Elasticsearch statefulset not found"
            kubectl rollout restart daemonset/fluentd-daemonset -n monitoring || echo "âš ï¸ Fluentd daemonset not found"
            
            echo "â³ Waiting for infrastructure to be ready..."
            # Wait for at least 1 pod of each service to be ready
            kubectl wait --for=condition=ready pod -l app=postgres -n infrastructure --timeout=5m || echo "âš ï¸ Postgres not ready"
            kubectl wait --for=condition=ready pod -l app=mongodb -n infrastructure --timeout=5m || echo "âš ï¸ MongoDB not ready"
            kubectl wait --for=condition=ready pod -l app=rabbitmq -n infrastructure --timeout=5m || echo "âš ï¸ RabbitMQ not ready"
            kubectl wait --for=condition=ready pod -l app=redis,role=master -n infrastructure --timeout=5m || echo "âš ï¸ Redis master not ready"
            
            # Wait for monitoring deployments - Elasticsearch FIRST (Fluentd depends on it)
            echo "â³ Waiting for Elasticsearch to be ready..."
            kubectl wait --for=condition=ready pod -l app=elasticsearch -n monitoring --timeout=5m || echo "âš ï¸ Elasticsearch not ready"
            
            echo "â³ Waiting for monitoring stack..."
            kubectl wait --for=condition=available --timeout=3m deployment/prometheus-depl -n monitoring || echo "âš ï¸ Prometheus not ready"
            kubectl wait --for=condition=available --timeout=3m deployment/grafana-depl -n monitoring || echo "âš ï¸ Grafana not ready"
            kubectl wait --for=condition=available --timeout=3m deployment/alertmanager-depl -n monitoring || echo "âš ï¸ Alertmanager not ready"
            
            echo "âœ… Infrastructure secrets and deployments updated"
            echo "ðŸ“Š Checking infrastructure pods..."
            kubectl get pods -n infrastructure
            kubectl get statefulset -n infrastructure || echo "âš ï¸ No StatefulSet found"
            kubectl get pvc -n infrastructure || echo "No PVC found"
            
            echo ""
            echo "ðŸ“ˆ Checking monitoring pods..."
            kubectl get pods -n monitoring || echo "âš ï¸ No monitoring pods found"
            kubectl get svc -n monitoring || echo "âš ï¸ No monitoring services found"
          EOF

  # ==========================================
  # JOB 11: DEPLOY SERVICES TO AWS EC2 (RUN AFTER INFRASTRUCTURE)
  # ==========================================
  deploy-services:
    name: ðŸš€ Deploy Services to EC2
    needs: 
      - detect-changes
      - deploy-infrastructure
      # CHá»œ Táº¤T Cáº¢ BUILD JOBS HOÃ€N THÃ€NH
      - build-auth
      - build-face-recognition
      - build-attendance
      - build-employee
      - build-leave
      - build-notification
      - build-reporting
    # âœ… CHá»ˆ CHáº Y Náº¾U INFRASTRUCTURE SUCCESS/SKIPPED + CÃ“ SERVICE THAY Äá»”I
    if: |
      always() && 
      (needs.deploy-infrastructure.result == 'success' || needs.deploy-infrastructure.result == 'skipped') &&
      (needs.detect-changes.outputs.auth == 'true' ||
       needs.detect-changes.outputs.face-recognition == 'true' ||
       needs.detect-changes.outputs.attendance == 'true' ||
       needs.detect-changes.outputs.employee == 'true' ||
       needs.detect-changes.outputs.leave == 'true' ||
       needs.detect-changes.outputs.notification == 'true' ||
       needs.detect-changes.outputs.reporting == 'true' ||
       needs.detect-changes.outputs.shared == 'true' ||
       github.event.inputs.service != '')
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts

      - name: Setup git credentials on EC2
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            # Configure git to use token for private repo
            git config --global credential.helper store
            echo "https://${{ secrets.GH_TOKEN }}:x-oauth-basic@github.com" > ~/.git-credentials
          EOF

      - name: Prepare deployment files
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            set -e
            cd ~/GRADUATE_PROJECT
            
            # --- ÄÃ‚Y LÃ€ PHáº¦N FIX Lá»–I GIT ---
            echo "ðŸ”„ Fetching latest code from GitHub..."
            git fetch origin

            echo "ðŸ”„ Forcing server code to match GitHub (origin/main)..."
            # Lá»‡nh nÃ y vá»©t bá» Táº¤T Cáº¢ thay Ä‘á»•i (cáº£ commit) trÃªn server
            git reset --hard origin/main
            git clean -fd # Dá»n dáº¹p cÃ¡c file rÃ¡c
            # --- Háº¾T PHáº¦N FIX Lá»–I GIT ---
            
            # NO MORE sed -i! We'll use kubectl set image instead to avoid git conflicts
            echo "âœ… Deployment files prepared (no in-place modifications)"
          EOF

      - name: Deploy Auth Service
        if: |
          needs.detect-changes.outputs.auth == 'true' ||
          needs.detect-changes.outputs.shared == 'true' ||
          github.event.inputs.service == 'all' ||
          github.event.inputs.service == 'auth'
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            set -e
            cd ~/GRADUATE_PROJECT
            git pull origin main
            
            # Create secret safely
            kubectl create secret generic auth-secrets \
              --from-literal=.env='${{ secrets.AUTH_SECRET }}' \
              -n graduate-project \
              --dry-run=client -o yaml | kubectl apply -f -
            
            # Apply deployment (with placeholder)
            # Apply deployment (with tranvukien125 hard-coded now)
            kubectl apply -f infra/k8s/services/auth/ -n graduate-project
            
            # Force restart to pick up new deployment config (fixes DNS issues)
            kubectl rollout restart deployment/auth-depl -n graduate-project
            
            # Wait for deployment to be ready
            kubectl rollout status deployment/auth-depl -n graduate-project --timeout=5m
            
            echo "âœ… Auth service deployed"
          EOF

      - name: Deploy Attendance Service
        if: |
          needs.detect-changes.outputs.attendance == 'true' ||
          needs.detect-changes.outputs.shared == 'true' ||
          github.event.inputs.service == 'all' ||
          github.event.inputs.service == 'attendance'
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            set -e
            cd ~/GRADUATE_PROJECT
            git pull origin main
            
            # Create secret safely
            kubectl create secret generic attendance-secrets \
              --from-literal=.env='${{ secrets.ATTENDANCE_SECRET }}' \
              -n graduate-project \
              --dry-run=client -o yaml | kubectl apply -f -
            
            # Apply deployment (with placeholder)
            # Apply deployment
            kubectl apply -f infra/k8s/services/attendance/ -n graduate-project
            
            # Force restart to pick up new deployment config
            kubectl rollout restart deployment/attendance-depl -n graduate-project
            
            # Wait for deployment to be ready
            kubectl rollout status deployment/attendance-depl -n graduate-project --timeout=5m
            
            echo "âœ… Attendance service deployed"
          EOF

      - name: Deploy Employee Service
        if: |
          needs.detect-changes.outputs.employee == 'true' ||
          needs.detect-changes.outputs.shared == 'true' ||
          github.event.inputs.service == 'all' ||
          github.event.inputs.service == 'employee'
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            set -e
            cd ~/GRADUATE_PROJECT
            git pull origin main
            
            # Create secret safely
            kubectl create secret generic employee-secrets \
              --from-literal=.env='${{ secrets.EMPLOYEE_SECRET }}' \
              -n graduate-project \
              --dry-run=client -o yaml | kubectl apply -f -
            
            # Apply deployment (with placeholder)
            kubectl apply -f infra/k8s/services/employee/ -n graduate-project
            
            # Force restart to pick up new deployment config
            kubectl rollout restart deployment/employee-depl -n graduate-project
            
            # Wait for deployment to be ready
            kubectl rollout status deployment/employee-depl -n graduate-project --timeout=5m
            
            echo "âœ… Employee service deployed"
          EOF

      - name: Deploy Leave Service
        if: |
          needs.detect-changes.outputs.leave == 'true' ||
          needs.detect-changes.outputs.shared == 'true' ||
          github.event.inputs.service == 'all' ||
          github.event.inputs.service == 'leave'
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            set -e
            cd ~/GRADUATE_PROJECT
            git pull origin main
            
            # Create secret safely
            kubectl create secret generic leave-secrets \
              --from-literal=.env='${{ secrets.LEAVE_SECRET }}' \
              -n graduate-project \
              --dry-run=client -o yaml | kubectl apply -f -
            
            # Apply deployment (with placeholder)
            kubectl apply -f infra/k8s/services/leave/ -n graduate-project
            
            # Force restart to pick up new deployment config
            kubectl rollout restart deployment/leave-depl -n graduate-project
            
            # Wait for deployment to be ready
            kubectl rollout status deployment/leave-depl -n graduate-project --timeout=5m
            
            echo "âœ… Leave service deployed"
          EOF

      - name: Deploy Notification Service
        if: |
          needs.detect-changes.outputs.notification == 'true' ||
          needs.detect-changes.outputs.shared == 'true' ||
          github.event.inputs.service == 'all' ||
          github.event.inputs.service == 'notification'
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            set -e
            cd ~/GRADUATE_PROJECT
            git pull origin main
            
            # Create secret safely
            kubectl create secret generic notification-secrets \
              --from-literal=.env='${{ secrets.NOTIFICATION_SECRET }}' \
              -n graduate-project \
              --dry-run=client -o yaml | kubectl apply -f -
            
            # Apply deployment (with placeholder)
            kubectl apply -f infra/k8s/services/notification/ -n graduate-project
            
            # Force restart to pick up new deployment config
            kubectl rollout restart deployment/notification-depl -n graduate-project
            
            # Wait for deployment to be ready
            kubectl rollout status deployment/notification-depl -n graduate-project --timeout=5m
            
            echo "âœ… Notification service deployed"
          EOF

      - name: Deploy Reporting Service
        if: |
          needs.detect-changes.outputs.reporting == 'true' ||
          needs.detect-changes.outputs.shared == 'true' ||
          github.event.inputs.service == 'all' ||
          github.event.inputs.service == 'reporting'
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            set -e
            cd ~/GRADUATE_PROJECT
            git pull origin main
            
            # Create secret safely
            kubectl create secret generic reporting-secrets \
              --from-literal=.env='${{ secrets.REPORTING_SECRET }}' \
              -n graduate-project \
              --dry-run=client -o yaml | kubectl apply -f -
            
            # Apply deployment (with placeholder)
            kubectl apply -f infra/k8s/services/reporting/ -n graduate-project
            
            # Force restart to pick up new deployment config
            kubectl rollout restart deployment/reporting-depl -n graduate-project
            
            # Wait for deployment to be ready
            kubectl rollout status deployment/reporting-depl -n graduate-project --timeout=5m
            
            echo "âœ… Reporting service deployed"
          EOF

      - name: Deploy Face Recognition Service
        if: |
          needs.detect-changes.outputs.face-recognition == 'true' ||
          github.event.inputs.service == 'all' ||
          github.event.inputs.service == 'face-recognition'
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            set -e
            cd ~/GRADUATE_PROJECT
            git pull origin main
            
            # Create secret from env file (each line becomes a key)
            # Convert multiline secret to --from-env-file format
            echo '${{ secrets.FACE_RECOGNITION_SECRET }}' > /tmp/face-recognition.env
            
            kubectl create secret generic face-recognition-secrets \
              --from-env-file=/tmp/face-recognition.env \
              -n graduate-project \
              --dry-run=client -o yaml | kubectl apply -f -
            
            # Clean up temp file
            rm -f /tmp/face-recognition.env
            
            # Apply deployment (with placeholder)
            kubectl apply -f infra/k8s/services/face-recognition/ -n graduate-project
            
            # Force restart to pick up new deployment config
            kubectl rollout restart deployment/face-recognition-depl -n graduate-project
            
            # Wait for deployment to be ready
            kubectl rollout status deployment/face-recognition-depl -n graduate-project --timeout=5m
            
            echo "âœ… Face Recognition service deployed"
          EOF

      - name: Verify deployment
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            echo "ðŸ“Š Deployment Status:"
            echo ""
            echo "=== Pods in graduate-project namespace ==="
            kubectl get pods -n graduate-project
            echo ""
            echo "=== Services in graduate-project namespace ==="
            kubectl get svc -n graduate-project
            echo ""
            echo "=== Secrets in graduate-project namespace ==="
            kubectl get secrets -n graduate-project
          EOF

  # ==========================================
  # JOB 12: NOTIFY DEPLOYMENT STATUS
  # ==========================================
  notify:
    name: ðŸ“¢ Notify Deployment Status
    needs: 
      - deploy-infrastructure
      - deploy-services
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Send Slack notification
        if: vars.SLACK_WEBHOOK_URL != ''
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "ðŸš€ Deployment to AWS EC2",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Infrastructure:* ${{ needs.deploy-infrastructure.result }}\n*Services:* ${{ needs.deploy-services.result }}\n*Branch:* ${{ github.ref_name }}\n*Commit:* ${{ github.sha }}\n*Author:* ${{ github.actor }}"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

